/**
 * \file	audio.c
 * \brief	Audio core of the hearing aid software.
 *
 * \details	This file contains the I/Os management of the system and by
 *		definition the audio core of the hearing aid.
 */
#include <stdio.h>
#include <stdlib.h>

#include <portaudio.h>
#include "yajl/yajl_tree.h"
#include "tools.h"
#include "ringbuffer.h"
#include "filters.h"
#include "parser.h"

static PaError err;
static PaStream *stream = {0};
static SAMPLE first_fir = {0};
/* low-pass coefficients for 10 taps */
#define NTAPS 21
static SAMPLE z[2 * NTAPS];
static SAMPLE coefficients[NTAPS] =
{
	0.0068831,	0.0089553,	0.0148626,	0.0241587,
	0.0360157,	0.0493076,	0.0627273,	0.0749272,
	0.0846656,	0.0909423,	0.0931093,	0.0909423,
	0.0846656,	0.0749272,	0.0627273,	0.0493076,
	0.0360157,	0.0241587,	0.0148626,	0.0089553,
	0.0068831
};


/**
 * \fn		void PaErrorTest(PaError error)
 * \brief	Portaudio error handling
 *
 * \param[in]	error			error generated by Portaudio engine
 *
 * The function will return an error message on stderr if fails
 */
void PaErrorTest(PaError error)
{
	if (error != paNoError) {
		/* using Pa_Terminate is crucial to avoid resource leaks */
		Pa_Terminate();
		fprintf(stderr, "Error: %s\n", Pa_GetErrorText(error));
		exit(EXIT_FAILURE);
	}
}


/**
 * \fn		int PlayrecCallback(const void *input_buffer, void *output_buffer,
 *		unsigned long frames_per_buffer, const PaStreamCallbackTimeInfo *time_info,
 *		PaStreamCallbackFlags status_flags, void *user_data)
 *
 * \brief	Audio callback
 *
 *
 * \param[in] input_buffer		array of interleaved input samples
 * \param[in] output_buffer		array of interleaved output samples
 * \param[in] frames_per_buffer		number of frames to be processed
 * \param[in] time_info			struct with time in seconds
 * \param[in] status_flags		flags indicating whether input and/or
 * \param[in] user_data			pointer to the StreamInfoStruct for this
 *					stream, as passed to Pa_OpenStream()
 *
 * \return	paContinue or paAbort to stop the stream if either user_data
 *		is NULL or stopStream has been set, or paContinue for the
 *		stream to continue running.
 */
int g_num_no_imputs = {0};
int PlayrecCallback(const void *input_buffer,
			   void *output_buffer,
			   unsigned long frames_per_buffer,
			   const PaStreamCallbackTimeInfo *time_info,
			   PaStreamCallbackFlags status_flags,
			   void *user_data)
{
	float *out = (float *) output_buffer;
	const float *in = (const float *)input_buffer;
	unsigned int i;

	(void) time_info;
	(void) status_flags;
	(void) user_data;

	/* we transfer the input samples to the output */
	if (input_buffer != NULL) {
		for (i = 0; i < frames_per_buffer; i++) {
			*out++ = fir_basic(*in++, NTAPS, coefficients, z);
			*out++ = fir_basic(*in++, NTAPS, coefficients, z);
			/*
			*out++ = *in++;
			*out++ = *in++;
			 */
		}
	}
	return paContinue;
}


/**
 * \fn		static void PaInit(void)
 * \brief	Initialization of Portaudio framework.
 *
 * if an error is raised, the program exit with an error message on stderr.
 */
static void PaInit(void)
{
	static int initialized;

	if (!initialized) {
		err = Pa_Initialize();

		PaErrorTest(err);
		initialized = 1;
	}
}


/**
 * \fn		static void PaClose(PaStream *stream)
 * \brief	Close the audio stream gracefully.
 *
 * \param[in]	stream			Pointer to the audio stream
 *
 * Finish gracefully the audio stream or exit the program if an error is raised
 */
static void PaClose(PaStream *stream)
{
	err = Pa_StopStream(stream);
	PaErrorTest(err);
	Pa_Terminate();
}


/**
 * \fn			void PaOpenStream(void)
 * \brief		Open the audio stream through Portaudio framework.
 *
 * Exit and return an error if raised
 *
 * \todo There are multiple things to do:
 * - Find a way to include the sample format in the configuration file. In other
 *   words, the sample_format is a string in the configuration file and should a
 *   PaSampleFormat.
 * - Check with IsParamExist the input/output_latency parameter and if specified
 *   return the latency otherwise use defaultLowInput/OutputLatency from
 *   portaudio
 * - get information about the hostApiSpecificStreamInfo to understand the exact
 *   information that should be stored inside.
 */
void PaOpenStream(void)
{
	PaStreamParameters in_params, out_params;
	char sample_format = paFloat32;

	PaInit();

	/* Parse the configuration file */
	yajl_val node = LoadConfigFile();

	/* input configuration */
	in_params.device = GetIntegerParam(node, "deviceSetup", "device_id");
	in_params.sampleFormat = sample_format;
	in_params.channelCount = GetIntegerParam(node, "deviceSetup", "input_channels");
	in_params.suggestedLatency =
		Pa_GetDeviceInfo(in_params.device)->defaultLowInputLatency;
	in_params.hostApiSpecificStreamInfo = NULL;

	/* output configuration */
	out_params.device = GetIntegerParam(node, "deviceSetup", "device_id");
	out_params.sampleFormat = sample_format;
	out_params.channelCount = GetIntegerParam(node, "deviceSetup", "output_channels");
	out_params.suggestedLatency =
		Pa_GetDeviceInfo(out_params.device)->defaultLowOutputLatency;
	out_params.hostApiSpecificStreamInfo = NULL;

	/* misc configuration */
	int samplerate = GetIntegerParam(node, "deviceSetup", "samplerate");
	int frames_per_buffer = GetIntegerParam(node, "deviceSetup", "frames_per_buffer");

	/* free the node */
	FreeConfigFile(node);

	RingBuffer_t buffer;

	RingBufferInit(&buffer);

	err = Pa_OpenStream(
			   &stream,
			   &in_params,
			   &out_params,
			   samplerate,
			   frames_per_buffer,
			   paNoFlag, /* portaudio will clip for us */
			   PlayrecCallback,
			   NULL);
	PaErrorTest(err);

	err = Pa_StartStream(stream);
	PaErrorTest(err);

	/* close the program when wanted */
	printf("Hit ENTER to stop program.\n");
	getchar();
	/* stop the stream */
	PaClose(stream);
}
